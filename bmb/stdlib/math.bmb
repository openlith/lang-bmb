# BMB Standard Library: Math Functions
# "Omission is guessing, and guessing is error."

@node abs
@params x:i32
@returns i32
@pre true
@post ret >= 0
@post (x >= 0 && ret == x) || (x < 0 && ret == 0 - x)

  lt %neg x 0
  jif %neg _negate
  ret x
_negate:
  sub %r 0 x
  ret %r

@node max
@params a:i32 b:i32
@returns i32
@pre true
@post ret >= a && ret >= b

  gt %a_gt a b
  jif %a_gt _ret_a
  ret b
_ret_a:
  ret a

@node min
@params a:i32 b:i32
@returns i32
@pre true
@post ret <= a && ret <= b

  lt %a_lt a b
  jif %a_lt _ret_a
  ret b
_ret_a:
  ret a

@node clamp
@params x:i32 low:i32 high:i32
@returns i32
@pre low <= high
@post ret >= low && ret <= high

  lt %too_low x low
  jif %too_low _ret_low
  gt %too_high x high
  jif %too_high _ret_high
  ret x
_ret_low:
  ret low
_ret_high:
  ret high

@node sign
@params x:i32
@returns i32
@pre true
@post ret == 1 || ret == 0 || ret == 0 - 1

  eq %is_zero x 0
  jif %is_zero _ret_zero
  lt %is_neg x 0
  jif %is_neg _ret_neg
  mov %r 1
  ret %r
_ret_zero:
  mov %r 0
  ret %r
_ret_neg:
  sub %r 0 1
  ret %r

@node pow_simple
@params base:i32 exp:i32
@returns i32
@pre exp >= 0
@post true

  eq %exp_zero exp 0
  jif %exp_zero _ret_one
  mov %result 1
  mov %i 0
_loop:
  ge %done %i exp
  jif %done _end
  mul %result %result base
  add %i %i 1
  jmp _loop
_ret_one:
  mov %result 1
  ret %result
_end:
  ret %result

@node factorial
@params n:i32
@returns i32
@pre n >= 0 && n <= 12
@post ret >= 1

  eq %is_zero n 0
  jif %is_zero _ret_one
  mov %result 1
  mov %i 1
_loop:
  gt %done %i n
  jif %done _end
  mul %result %result %i
  add %i %i 1
  jmp _loop
_ret_one:
  mov %result 1
  ret %result
_end:
  ret %result

@node gcd
@params a:i32 b:i32
@returns i32
@pre a >= 0 && b >= 0
@post ret >= 0

  eq %b_zero b 0
  jif %b_zero _ret_a
_loop:
  mod %rem a b
  mov a b
  mov b %rem
  eq %b_zero b 0
  jif %b_zero _ret_a
  jmp _loop
_ret_a:
  ret a

@node lcm
@params a:i32 b:i32
@returns i32
@pre a > 0 && b > 0
@post ret >= a && ret >= b

  # LCM = (a * b) / GCD(a, b)
  # First compute GCD
  mov %orig_a a
  mov %orig_b b
  eq %b_zero b 0
  jif %b_zero _have_gcd
_gcd_loop:
  mod %rem a b
  mov a b
  mov b %rem
  eq %b_zero b 0
  jif %b_zero _have_gcd
  jmp _gcd_loop
_have_gcd:
  # a now contains GCD
  mul %prod %orig_a %orig_b
  div %result %prod a
  ret %result
