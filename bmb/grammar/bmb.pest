// BMB (Bare-Metal-Banter) PEG Grammar
// Version 0.3
//
// "Omission is guessing, and guessing is error."

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// Program structure - now includes struct and enum definitions
program = { SOI ~ import* ~ (struct_def | enum_def | node)* ~ EOI }

// Struct definition
// @struct Point
//   x:f64
//   y:f64
struct_def = {
    "@struct" ~ ident ~ struct_field+
}
struct_field = { ident ~ ":" ~ type_spec }

// Enum definition
// @enum Result
//   Ok:i32
//   Err:i32
enum_def = {
    "@enum" ~ ident ~ enum_variant+
}
enum_variant = { ident ~ (":" ~ type_spec)? }

// External function imports
// Example: @import print_i32(i32)
// Example: @import print_newline()
import = {
    "@import" ~ ident ~ "(" ~ import_params? ~ ")"
}

// Import parameter types (no names, just types)
import_params = { type_name ~ ("," ~ type_name)* }

// Node (function) definition
node = {
    "@node" ~ ident ~
    params ~
    returns ~
    contracts ~
    body
}

// Parameters
params = { "@params" ~ param* }
param = { ident ~ ":" ~ type_name }

// Return type
returns = { "@returns" ~ type_name }

// Contracts (can have multiple @pre and @post)
contracts = { (pre | post)* }
pre = { "@pre" ~ expr }
post = { "@post" ~ expr }

// Function body - explicitly mark start with indented instructions
body = { (label | stmt)+ }

// Labels use underscore prefix (e.g., _loop:, _end:)
// Must include the colon to distinguish from label_ref in operands
label = @{ "_" ~ (ASCII_ALPHA | ASCII_DIGIT | "_")+ ~ ":" }

// Statements - opcode followed by operands
stmt = { opcode ~ operand* }

// Opcodes - must be checked before ident in operand
opcode = @{
    ("add" | "sub" | "mul" | "div" | "mod" |
     "eq" | "ne" | "lt" | "le" | "gt" | "ge" |
     "ret" | "jmp" | "jif" | "call" | "xcall" |
     "mov" | "load" | "store" | "print") ~ !ASCII_ALPHANUMERIC
}

// Operands
operand = { register | label_ref | str_literal | float_literal | int_literal | field_access | array_access | ident }
register = @{ "%" ~ (ASCII_ALPHA | ASCII_DIGIT | "_")+ }
// label_ref must NOT be followed by colon (that would be a label definition)
label_ref = @{ "_" ~ (ASCII_ALPHA | ASCII_DIGIT | "_")+ ~ !":" }

// Field access: obj.field (for structs)
field_access = { ident ~ "." ~ ident }

// Array access: arr[index] where index can be register or int
array_access = { ident ~ "[" ~ (register | int_literal | ident) ~ "]" }

// String literal with escape sequences
str_literal = ${ "\"" ~ str_inner ~ "\"" }
str_inner = @{ str_char* }
str_char = { !("\"" | "\\") ~ ANY | "\\" ~ ("\"" | "\\" | "n" | "r" | "t" | "0") }

// Types
// type_spec is the main type rule (supports arrays, references, user types)
type_spec = { array_type | ref_type | primitive_type | user_type }

// Primitive types
primitive_type = { "i32" | "i64" | "f32" | "f64" | "bool" | "void" }

// Array type: [T; N] where T is element type and N is size
array_type = { "[" ~ type_spec ~ ";" ~ array_size ~ "]" }
array_size = @{ ASCII_DIGIT+ }

// Reference type: &T
ref_type = { "&" ~ type_spec }

// User-defined type (struct or enum name)
user_type = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Legacy alias for backwards compatibility
type_name = { type_spec }

// Expressions (for contracts)
expr = { or_expr }

or_expr = { and_expr ~ ("||" ~ and_expr)* }
and_expr = { comparison ~ ("&&" ~ comparison)* }
comparison = { term ~ (comp_op ~ term)? }
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }

term = { factor ~ (term_op ~ factor)* }
term_op = { "+" | "-" }

factor = { unary ~ (factor_op ~ unary)* }
factor_op = { "*" | "/" | "%" }

unary = { unary_op? ~ primary }
unary_op = { "!" | "-" }

// 'ret' is a special keyword in contracts that refers to return value
primary = { "(" ~ expr ~ ")" | float_literal | int_literal | bool_literal | ret_keyword | ident }
ret_keyword = { "ret" ~ !ASCII_ALPHANUMERIC }

// Literals
float_literal = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
int_literal = @{ "-"? ~ ASCII_DIGIT+ }
bool_literal = { "true" | "false" }

// Reserved keywords (opcodes and boolean literals)
reserved = @{
    ("add" | "sub" | "mul" | "div" | "mod" |
     "eq" | "ne" | "lt" | "le" | "gt" | "ge" |
     "ret" | "jmp" | "jif" | "call" | "xcall" |
     "mov" | "load" | "store" | "print" |
     "true" | "false") ~ !ASCII_ALPHANUMERIC
}

// Identifiers (must NOT start with underscore, and must NOT be a reserved keyword)
ident = @{ !reserved ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
