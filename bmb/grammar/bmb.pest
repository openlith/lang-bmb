// BMB (Bare-Metal-Banter) PEG Grammar
// Version 0.4
//
// "Omission is guessing, and guessing is error."
//
// Self-Describing Syntax:
//   @ = directive (metadata)
//   % = register (storage)
//   _ = label (jump target)

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// Program structure - includes module declaration, imports, types, data, and nodes
program = { SOI ~ module_decl? ~ (import | use_module)* ~ (struct_def | enum_def | data_def)* ~ node* ~ EOI }

// Data segment definition (static byte data in memory)
// @data name "string literal"
// @data name [1, 2, 3, 4]  # byte array
data_def = {
    "@data" ~ ident ~ (str_literal | byte_array)
}
byte_array = { "[" ~ int_literal ~ ("," ~ int_literal)* ~ "]" }

// Module declaration (for Index system - replaces documentation)
// @module math.arithmetic  OR  @. math.arithmetic (compact)
module_decl = {
    ("@module" | "@.") ~ module_name
}
module_name = @{ ident ~ ("." ~ ident)* }

// Module import (brings in another BMB module)
// @use "path/to/module.bmb" as alias
// @use math
use_module = {
    "@use" ~ (module_path | ident) ~ ("as" ~ ident)?
}
module_path = ${ "\"" ~ module_path_inner ~ "\"" }
module_path_inner = @{ (!("\"") ~ ANY)+ }

// Struct definition
// @struct Point
//   x:f64
//   y:f64
struct_def = {
    "@struct" ~ ident ~ struct_field+
}
struct_field = { ident ~ ":" ~ type_spec }

// Enum definition
// @enum Result
//   Ok:i32
//   Err:i32
enum_def = {
    "@enum" ~ ident ~ enum_variant+
}
enum_variant = { ident ~ (":" ~ type_spec)? }

// External function imports
// Example: @import print_i32(i32)
// Example: @import print_newline()
import = {
    "@import" ~ ident ~ "(" ~ import_params? ~ ")"
}

// Import parameter types (no names, just types)
import_params = { type_name ~ ("," ~ type_name)* }

// Node (function) definition
// Full syntax: @node, @params, @returns, @pre, @post, @tags, @test
// Compact:     @n,    @p,      @r,       @<,   @>,    @#,    @?
node = {
    ("@node" | "@n") ~ ident ~
    node_tags? ~
    params ~
    returns ~
    contracts ~
    tests ~
    body
}

// Tags for Index system (replaces documentation)
// @tags [math, pure, safe]  OR  @# [math, pure, safe] (compact)
node_tags = {
    ("@tags" | "@#") ~ "[" ~ tag_list ~ "]"
}
tag_list = { ident ~ ("," ~ ident)* }

// Test cases (executable contracts)
// @test expect(factorial(5), 120)  OR  @? expect(...) (compact)
tests = { test_case* }
test_case = {
    ("@test" | "@?") ~ test_expr
}
test_expr = { ident ~ "(" ~ test_args? ~ ")" }
test_args = { test_arg ~ ("," ~ test_arg)* }
test_arg = { float_literal | int_literal | bool_literal | ident ~ "(" ~ test_args? ~ ")" | ident }

// Parameters
// @params a:i32 b:i32  OR  @p a:i32 b:i32 (compact)
params = { ("@params" | "@p") ~ param* }
param = { ident ~ ":" ~ type_name }

// Return type
// @returns i32  OR  @r i32 (compact)
returns = { ("@returns" | "@r") ~ type_name }

// Contracts (replaces comments with verifiable rules)
// Can have multiple @pre, @post, @invariant, @assert
contracts = { (pre | post | invariant | assert_stmt)* }

// Precondition: @pre condition  OR  @< condition (compact)
pre = { ("@pre" | "@<") ~ expr }

// Postcondition: @post condition  OR  @> condition (compact)
post = { ("@post" | "@>") ~ expr }

// Loop invariant: @invariant _label condition  OR  @~ _label condition (compact)
invariant = { ("@invariant" | "@~") ~ label_ref ~ expr }

// Inline assertion: @assert condition  OR  @! condition (compact)
// Note: assertions are checked at the point they appear in code
assert_stmt = { ("@assert" | "@!") ~ expr }

// Function body - explicitly mark start with indented instructions
body = { (label | stmt)+ }

// Labels use underscore prefix (e.g., _loop:, _end:)
// Must include the colon to distinguish from label_ref in operands
label = @{ "_" ~ (ASCII_ALPHA | ASCII_DIGIT | "_")+ ~ ":" }

// Statements - opcode followed by operands
stmt = { opcode ~ operand* }

// Opcodes - must be checked before ident in operand
opcode = @{
    ("add" | "sub" | "mul" | "div" | "mod" |
     "eq" | "ne" | "lt" | "le" | "gt" | "ge" |
     "ret" | "jmp" | "jif" | "call" | "xcall" |
     "mov" | "load" | "store" | "print") ~ !ASCII_ALPHANUMERIC
}

// Operands
// qualified_ident must come before ident to match module.function patterns
operand = { register | label_ref | str_literal | char_literal | float_literal | int_literal | field_access | array_access | qualified_ident | ident }

// Qualified identifier for module references: module.function
qualified_ident = { ident ~ "::" ~ ident }
register = @{ "%" ~ (ASCII_ALPHA | ASCII_DIGIT | "_")+ }
// label_ref must NOT be followed by colon (that would be a label definition)
label_ref = @{ "_" ~ (ASCII_ALPHA | ASCII_DIGIT | "_")+ ~ !":" }

// Field access: obj.field (for structs)
field_access = { ident ~ "." ~ ident }

// Array access: arr[index] where index can be register or int
array_access = { ident ~ "[" ~ (register | int_literal | ident) ~ "]" }

// String literal with escape sequences
str_literal = ${ "\"" ~ str_inner ~ "\"" }
str_inner = @{ str_char* }
str_char = { !("\"" | "\\") ~ ANY | "\\" ~ ("\"" | "\\" | "n" | "r" | "t" | "0") }

// Character literal: 'A', 'í•œ', '\n', '\x41'
char_literal = ${ "'" ~ char_inner ~ "'" }
char_inner = @{ char_escape | (!("'" | "\\") ~ ANY) }
char_escape = { "\\" ~ ("'" | "\\" | "n" | "r" | "t" | "0" | hex_escape | unicode_escape) }
hex_escape = { "x" ~ ASCII_HEX_DIGIT{2} }
unicode_escape = { "u" ~ "{" ~ ASCII_HEX_DIGIT{1,6} ~ "}" }

// Types
// type_spec is the main type rule (supports arrays, references, pointers, user types)
type_spec = { array_type | ref_type | ptr_type | primitive_type | user_type }

// Primitive types
// Signed: i8, i16, i32, i64
// Unsigned: u8, u16, u32, u64
// Float: f32, f64
// Other: bool, char, void
primitive_type = {
    "i64" | "i32" | "i16" | "i8" |
    "u64" | "u32" | "u16" | "u8" |
    "f64" | "f32" |
    "bool" | "char" | "void"
}

// Array type: [T; N] where T is element type and N is size
array_type = { "[" ~ type_spec ~ ";" ~ array_size ~ "]" }
array_size = @{ ASCII_DIGIT+ }

// Reference type: &T
ref_type = { "&" ~ type_spec }

// Pointer type: *T (raw pointer for low-level memory access)
ptr_type = { "*" ~ type_spec }

// User-defined type (struct or enum name)
user_type = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Legacy alias for backwards compatibility
type_name = { type_spec }

// Expressions (for contracts)
expr = { or_expr }

or_expr = { and_expr ~ ("||" ~ and_expr)* }
and_expr = { comparison ~ ("&&" ~ comparison)* }
comparison = { term ~ (comp_op ~ term)? }
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }

term = { factor ~ (term_op ~ factor)* }
term_op = { "+" | "-" }

factor = { unary ~ (factor_op ~ unary)* }
factor_op = { "*" | "/" | "%" }

unary = { unary_op? ~ primary }
unary_op = { "!" | "-" }

// 'ret' is a special keyword in contracts that refers to return value
// 'old(expr)' refers to the pre-state value of an expression
primary = { "(" ~ expr ~ ")" | old_expr | float_literal | int_literal | bool_literal | ret_keyword | ident }
ret_keyword = { "ret" ~ !ASCII_ALPHANUMERIC }
old_expr = { "old" ~ "(" ~ expr ~ ")" }

// Literals
float_literal = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
int_literal = @{ "-"? ~ ASCII_DIGIT+ }
bool_literal = { "true" | "false" }

// Reserved keywords (opcodes and boolean literals)
reserved = @{
    ("add" | "sub" | "mul" | "div" | "mod" |
     "eq" | "ne" | "lt" | "le" | "gt" | "ge" |
     "ret" | "jmp" | "jif" | "call" | "xcall" |
     "mov" | "load" | "store" | "print" |
     "true" | "false") ~ !ASCII_ALPHANUMERIC
}

// Identifiers (must NOT start with underscore, and must NOT be a reserved keyword)
ident = @{ !reserved ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
