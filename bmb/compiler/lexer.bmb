# BMB Self-Hosting Compiler - Lexer
# v0.16.0: Lexer & Tokenizer in BMB
#
# Philosophy: "Omission is guessing, and guessing is error"
# Explicit state tracking, no hidden side effects.

@use "token"

# Host function declarations for string operations
@extern "C" from "bmb_stdlib"
@node string_len_h
@params handle:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node string_get_byte
@params handle:i32 index:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node string_new
@params
@returns i32

@extern "C" from "bmb_stdlib"
@node string_push_byte
@params handle:i32 byte:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node string_drop
@params handle:i32
@returns i32

# Host function declarations for character classification
@extern "C" from "bmb_stdlib"
@node is_digit
@params byte:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node is_alpha
@params byte:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node is_whitespace
@params byte:i32
@returns i32

# Lexer state - passed explicitly to all functions
# (BMB doesn't have mutable structs yet, so we use separate parameters)

# ============================================
# Character Utilities
# ============================================

# is_at_end: Check if lexer has reached end of source
@node is_at_end
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  xcall %len string_len_h source
  ge %cmp pos %len
  jif %cmp _yes
  mov %result 0
  ret %result
_yes:
  mov %result 1
  ret %result

# peek: Look at current character without consuming
# Returns -1 if at end
@node peek
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= -1
  call %at_end is_at_end source pos
  ne %at_end_bool %at_end 0
  jif %at_end_bool _eof
  xcall %byte string_get_byte source pos
  ret %byte
_eof:
  mov %result -1
  ret %result

# peek_next: Look at next character (pos+1) without consuming
# Returns -1 if would be at or past end
@node peek_next
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= -1
  add %next_pos pos 1
  call %at_end is_at_end source %next_pos
  ne %at_end_bool %at_end 0
  jif %at_end_bool _eof
  xcall %byte string_get_byte source %next_pos
  ret %byte
_eof:
  mov %result -1
  ret %result

# advance: Consume current character and return new position
# Returns pos+1 if not at end, pos if at end
@node advance
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= pos
  call %at_end is_at_end source pos
  ne %at_end_bool %at_end 0
  jif %at_end_bool _stay
  add %new_pos pos 1
  ret %new_pos
_stay:
  ret pos

# skip_whitespace: Skip whitespace characters, return new position
@node skip_whitespace
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= pos
  call %at_end is_at_end source pos
  ne %at_end_bool %at_end 0
  jif %at_end_bool _done
  call %ch peek source pos
  xcall %is_ws is_whitespace %ch
  eq %not_ws %is_ws 0
  jif %not_ws _done
  # Whitespace found, advance and recurse
  call %new_pos advance source pos
  call %result skip_whitespace source %new_pos
  ret %result
_done:
  ret pos

# ============================================
# Character Classification (BMB-specific)
# ============================================

# is_ident_start: Check if character can start an identifier
# Identifiers start with alpha or underscore
@node is_ident_start
@params byte:i32
@returns i32
@pre true
@post true
  # Check alpha
  xcall %is_a is_alpha byte
  ne %is_alpha_bool %is_a 0
  jif %is_alpha_bool _yes
  # Check underscore (95)
  eq %is_underscore byte 95
  jif %is_underscore _yes
  mov %result 0
  ret %result
_yes:
  mov %result 1
  ret %result

# is_ident_continue: Check if character can continue an identifier
# Identifiers continue with alphanumeric or underscore
@node is_ident_continue
@params byte:i32
@returns i32
@pre true
@post true
  # Check alpha
  xcall %is_a is_alpha byte
  ne %is_alpha_bool %is_a 0
  jif %is_alpha_bool _yes
  # Check digit
  xcall %is_d is_digit byte
  ne %is_digit_bool %is_d 0
  jif %is_digit_bool _yes
  # Check underscore (95)
  eq %is_underscore byte 95
  jif %is_underscore _yes
  mov %result 0
  ret %result
_yes:
  mov %result 1
  ret %result

# is_hex_digit: Check if character is hexadecimal digit
@node is_hex_digit
@params byte:i32
@returns i32
@pre true
@post true
  # Check 0-9
  xcall %is_d is_digit byte
  ne %is_digit_bool %is_d 0
  jif %is_digit_bool _yes
  # Check a-f (97-102)
  ge %ge_a byte 97
  le %le_f byte 102
  and %is_lower_hex %ge_a %le_f
  jif %is_lower_hex _yes
  # Check A-F (65-70)
  ge %ge_A byte 65
  le %le_F byte 70
  and %is_upper_hex %ge_A %le_F
  jif %is_upper_hex _yes
  mov %result 0
  ret %result
_yes:
  mov %result 1
  ret %result

# ============================================
# Single Character Token Detection
# ============================================

# ASCII character codes for reference:
# '@' = 64, ':' = 58, '%' = 37, '(' = 40, ')' = 41
# '[' = 91, ']' = 93, '{' = 123, '}' = 125, ',' = 44
# '+' = 43, '-' = 45, '*' = 42, '/' = 47
# '=' = 61, '!' = 33, '<' = 60, '>' = 62
# '&' = 38, '|' = 124, '^' = 94, '_' = 95
# '#' = 35, '\n' = 10

# get_single_char_token: Map single character to TokenKind
# Returns -1 if not a single-char token
@node get_single_char_token
@params byte:i32
@returns i32
@pre byte >= 0
@post ret >= -1
  # '@' = 64 -> At (45)
  eq %is_at byte 64
  jif %is_at _at
  # ':' = 58 -> Colon (46)
  eq %is_colon byte 58
  jif %is_colon _colon
  # '%' = 37 -> Percent (47)
  eq %is_percent byte 37
  jif %is_percent _percent
  # '(' = 40 -> LParen (48)
  eq %is_lparen byte 40
  jif %is_lparen _lparen
  # ')' = 41 -> RParen (49)
  eq %is_rparen byte 41
  jif %is_rparen _rparen
  # '[' = 91 -> LBracket (50)
  eq %is_lbracket byte 91
  jif %is_lbracket _lbracket
  # ']' = 93 -> RBracket (51)
  eq %is_rbracket byte 93
  jif %is_rbracket _rbracket
  # '{' = 123 -> LBrace (52)
  eq %is_lbrace byte 123
  jif %is_lbrace _lbrace
  # '}' = 125 -> RBrace (53)
  eq %is_rbrace byte 125
  jif %is_rbrace _rbrace
  # ',' = 44 -> Comma (54)
  eq %is_comma byte 44
  jif %is_comma _comma
  # '+' = 43 -> Plus (58)
  eq %is_plus byte 43
  jif %is_plus _plus
  # '*' = 42 -> Star (60)
  eq %is_star byte 42
  jif %is_star _star
  # '/' = 47 -> Slash (61)
  eq %is_slash byte 47
  jif %is_slash _slash
  # '&' = 38 -> Ampersand (62)
  eq %is_amp byte 38
  jif %is_amp _amp
  # '|' = 124 -> Pipe (63)
  eq %is_pipe byte 124
  jif %is_pipe _pipe
  # '^' = 94 -> Caret (64)
  eq %is_caret byte 94
  jif %is_caret _caret
  # '\n' = 10 -> Newline (78)
  eq %is_newline byte 10
  jif %is_newline _newline
  # Not a single-char token
  mov %result -1
  ret %result

  # Labels in reverse order (workaround for label ordering bug)
_newline:
  mov %result 78
  ret %result
_caret:
  mov %result 64
  ret %result
_pipe:
  mov %result 63
  ret %result
_amp:
  mov %result 62
  ret %result
_slash:
  mov %result 61
  ret %result
_star:
  mov %result 60
  ret %result
_plus:
  mov %result 58
  ret %result
_comma:
  mov %result 54
  ret %result
_rbrace:
  mov %result 53
  ret %result
_lbrace:
  mov %result 52
  ret %result
_rbracket:
  mov %result 51
  ret %result
_lbracket:
  mov %result 50
  ret %result
_rparen:
  mov %result 49
  ret %result
_lparen:
  mov %result 48
  ret %result
_percent:
  mov %result 47
  ret %result
_colon:
  mov %result 46
  ret %result
_at:
  mov %result 45
  ret %result

# ============================================
# Lexer State
# State is passed as separate parameters until BMB supports mutable structs.
# Parameters: source (handle), pos, line, col, token_start
# ============================================

# ============================================
# Token Scanning
# ============================================

# scan_single_char_token: Try to scan a single-character token
# Returns: (token_kind << 16) | new_pos if matched, -1 if not matched
# Using packed return: high 16 bits = token kind, low 16 bits = new position
@node scan_single_char_token
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  lt %is_eof %ch 0
  jif %is_eof _not_matched
  call %kind get_single_char_token %ch
  lt %not_single %kind 0
  jif %not_single _not_matched
  # Matched! Pack (kind << 16) | (pos + 1)
  mul %kind_shifted %kind 65536
  add %new_pos pos 1
  add %result %kind_shifted %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# unpack_token_kind: Extract token kind from packed result
@node unpack_token_kind
@params packed:i32
@returns i32
@pre packed >= 0
@post ret >= 0
  div %kind packed 65536
  ret %kind

# unpack_position: Extract position from packed result
@node unpack_position
@params packed:i32
@returns i32
@pre packed >= 0
@post ret >= 0
  mod %pos packed 65536
  ret %pos

# ============================================
# Multi-Character Token Scanning
# ============================================

# ASCII codes: '=' = 61, '!' = 33, '<' = 60, '>' = 62, ':' = 58, '-' = 45

# scan_equals: Handle = and =>  and ==
# Returns packed result or -1 if not '='
@node scan_equals
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_eq %ch 61
  jif %not_eq _not_matched
  call %next peek_next source pos
  # Check for => (Arrow = 55)
  eq %is_arrow %next 62
  jif %is_arrow _arrow
  # Check for == (EqEq = 65)
  eq %is_eqeq %next 61
  jif %is_eqeq _eqeq
  # Single = is not a token in BMB (use mov opcode)
  mov %result -1
  ret %result
_arrow:
  mul %kind 55 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_eqeq:
  mul %kind 65 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_bang: Handle ! and !=
@node scan_bang
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_bang %ch 33
  jif %not_bang _not_matched
  call %next peek_next source pos
  # Check for != (BangEq = 66)
  eq %is_bangeq %next 61
  jif %is_bangeq _bangeq
  # Single ! is not used in BMB
  mov %result -1
  ret %result
_bangeq:
  mul %kind 66 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_less: Handle < and <=
@node scan_less
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_less %ch 60
  jif %not_less _not_matched
  call %next peek_next source pos
  # Check for <= (LeOp = 68)
  eq %is_leop %next 61
  jif %is_leop _leop
  # Single < (LtOp = 67)
  mul %kind 67 65536
  add %new_pos pos 1
  add %result %kind %new_pos
  ret %result
_leop:
  mul %kind 68 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_greater: Handle > and >=
@node scan_greater
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_greater %ch 62
  jif %not_greater _not_matched
  call %next peek_next source pos
  # Check for >= (GeOp = 70)
  eq %is_geop %next 61
  jif %is_geop _geop
  # Single > (GtOp = 69)
  mul %kind 69 65536
  add %new_pos pos 1
  add %result %kind %new_pos
  ret %result
_geop:
  mul %kind 70 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_colon_double: Handle :: (ColonColon = 56)
# Single : is handled by get_single_char_token
@node scan_colon_double
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_colon %ch 58
  jif %not_colon _not_matched
  call %next peek_next source pos
  eq %is_double %next 58
  jif %is_double _double
  mov %result -1
  ret %result
_double:
  mul %kind 56 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_minus: Handle - (Minus = 59)
# Note: -> is not used in BMB, we use => for arrows
@node scan_minus
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_minus %ch 45
  jif %not_minus _not_matched
  # Simple minus token (Minus = 59)
  mul %kind 59 65536
  add %new_pos pos 1
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_multi_char: Try all multi-character token patterns
@node scan_multi_char
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  # Try :: first (before single :)
  call %colon_result scan_colon_double source pos
  ge %colon_matched %colon_result 0
  jif %colon_matched _return_colon
  # Try =>  and ==
  call %eq_result scan_equals source pos
  ge %eq_matched %eq_result 0
  jif %eq_matched _return_eq
  # Try !=
  call %bang_result scan_bang source pos
  ge %bang_matched %bang_result 0
  jif %bang_matched _return_bang
  # Try < and <=
  call %less_result scan_less source pos
  ge %less_matched %less_result 0
  jif %less_matched _return_less
  # Try > and >=
  call %greater_result scan_greater source pos
  ge %greater_matched %greater_result 0
  jif %greater_matched _return_greater
  # Try -
  call %minus_result scan_minus source pos
  ge %minus_matched %minus_result 0
  jif %minus_matched _return_minus
  # No match
  mov %result -1
  ret %result
_return_minus:
  ret %minus_result
_return_greater:
  ret %greater_result
_return_less:
  ret %less_result
_return_bang:
  ret %bang_result
_return_eq:
  ret %eq_result
_return_colon:
  ret %colon_result

# ============================================
# Identifier and Keyword Scanning
# ============================================

# scan_identifier_length: Count characters in identifier starting at pos
# Returns the length of the identifier (0 if not an identifier start)
@node scan_identifier_length
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= 0
  call %ch peek source pos
  lt %is_eof %ch 0
  jif %is_eof _zero
  call %is_start is_ident_start %ch
  eq %not_start %is_start 0
  jif %not_start _zero
  # Count continuing characters
  add %next_pos pos 1
  call %rest_len scan_ident_continue_length source %next_pos
  add %total rest_len 1
  ret %total
_zero:
  mov %result 0
  ret %result

# scan_ident_continue_length: Count continuing identifier characters
@node scan_ident_continue_length
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= 0
  call %ch peek source pos
  lt %is_eof %ch 0
  jif %is_eof _zero
  call %is_cont is_ident_continue %ch
  eq %not_cont %is_cont 0
  jif %not_cont _zero
  add %next_pos pos 1
  call %rest_len scan_ident_continue_length source %next_pos
  add %total %rest_len 1
  ret %total
_zero:
  mov %result 0
  ret %result

# collect_identifier: Collect identifier bytes into a new string handle
# Returns string handle
@node collect_identifier
@params source:i32 start:i32 len:i32
@returns i32
@pre start >= 0
@pre len > 0
@post ret >= 0
  xcall %handle string_new
  mov %i 0
  add %end start len
_loop:
  ge %done %i len
  jif %done _done
  add %src_pos start %i
  xcall %byte string_get_byte source %src_pos
  xcall %dummy string_push_byte %handle %byte
  add %i %i 1
  jmp _loop
_done:
  ret %handle

# check_keyword_node: Check if identifier is "node" (after @)
# Returns 1 if matches, 0 otherwise
@node check_keyword_node
@params source:i32 start:i32 len:i32
@returns i32
@pre start >= 0
@post true
  # "node" = 110, 111, 100, 101
  ne %not_4 len 4
  jif %not_4 _no
  add %p0 start 0
  xcall %c0 string_get_byte source %p0
  ne %not_n %c0 110
  jif %not_n _no
  add %p1 start 1
  xcall %c1 string_get_byte source %p1
  ne %not_o %c1 111
  jif %not_o _no
  add %p2 start 2
  xcall %c2 string_get_byte source %p2
  ne %not_d %c2 100
  jif %not_d _no
  add %p3 start 3
  xcall %c3 string_get_byte source %p3
  ne %not_e %c3 101
  jif %not_e _no
  mov %result 1
  ret %result
_no:
  mov %result 0
  ret %result

# check_keyword_params: Check if identifier is "params"
@node check_keyword_params
@params source:i32 start:i32 len:i32
@returns i32
@pre start >= 0
@post true
  # "params" = 112, 97, 114, 97, 109, 115
  ne %not_6 len 6
  jif %not_6 _no
  add %p0 start 0
  xcall %c0 string_get_byte source %p0
  ne %not_p %c0 112
  jif %not_p _no
  add %p1 start 1
  xcall %c1 string_get_byte source %p1
  ne %not_a %c1 97
  jif %not_a _no
  add %p2 start 2
  xcall %c2 string_get_byte source %p2
  ne %not_r %c2 114
  jif %not_r _no
  add %p3 start 3
  xcall %c3 string_get_byte source %p3
  ne %not_a2 %c3 97
  jif %not_a2 _no
  add %p4 start 4
  xcall %c4 string_get_byte source %p4
  ne %not_m %c4 109
  jif %not_m _no
  add %p5 start 5
  xcall %c5 string_get_byte source %p5
  ne %not_s %c5 115
  jif %not_s _no
  mov %result 1
  ret %result
_no:
  mov %result 0
  ret %result

# check_keyword_returns: Check if identifier is "returns"
@node check_keyword_returns
@params source:i32 start:i32 len:i32
@returns i32
@pre start >= 0
@post true
  # "returns" = 114, 101, 116, 117, 114, 110, 115
  ne %not_7 len 7
  jif %not_7 _no
  add %p0 start 0
  xcall %c0 string_get_byte source %p0
  ne %not_r %c0 114
  jif %not_r _no
  add %p1 start 1
  xcall %c1 string_get_byte source %p1
  ne %not_e %c1 101
  jif %not_e _no
  add %p2 start 2
  xcall %c2 string_get_byte source %p2
  ne %not_t %c2 116
  jif %not_t _no
  add %p3 start 3
  xcall %c3 string_get_byte source %p3
  ne %not_u %c3 117
  jif %not_u _no
  add %p4 start 4
  xcall %c4 string_get_byte source %p4
  ne %not_r2 %c4 114
  jif %not_r2 _no
  add %p5 start 5
  xcall %c5 string_get_byte source %p5
  ne %not_n %c5 110
  jif %not_n _no
  add %p6 start 6
  xcall %c6 string_get_byte source %p6
  ne %not_s %c6 115
  jif %not_s _no
  mov %result 1
  ret %result
_no:
  mov %result 0
  ret %result

# scan_identifier_or_keyword: Scan identifier and check for keywords
# Returns packed (kind << 16) | new_pos
# Ident = 74, Register = 75, Label = 76
# KwNode = 0, KwParams = 1, KwReturns = 2
@node scan_identifier_or_keyword
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %len scan_identifier_length source pos
  eq %no_ident %len 0
  jif %no_ident _not_matched
  # Collect the identifier string
  call %handle collect_identifier source pos %len
  add %new_pos pos %len
  # Check for keywords (only after @)
  # For now, just return as Ident
  mul %kind 74 65536
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_register: Scan register (%name)
# Returns packed result or -1
@node scan_register
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_percent %ch 37
  jif %not_percent _not_matched
  # Must have identifier after %
  add %id_start pos 1
  call %len scan_identifier_length source %id_start
  eq %no_name %len 0
  jif %no_name _not_matched
  # Collect register name
  call %handle collect_identifier source %id_start %len
  add %new_pos pos 1
  add %new_pos %new_pos %len
  # Register = 75
  mul %kind 75 65536
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_label: Scan label (_name or _name:)
# Returns packed result or -1
@node scan_label
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_underscore %ch 95
  jif %not_underscore _not_matched
  # Scan the label name (underscore + alphanumeric)
  add %id_start pos 1
  call %len scan_ident_continue_length source %id_start
  add %total_len %len 1
  # Collect label name
  call %handle collect_identifier source pos %total_len
  add %new_pos pos %total_len
  # Check for trailing colon (label definition)
  call %next_ch peek source %new_pos
  eq %has_colon %next_ch 58
  jif %has_colon _with_colon
  # Label = 76
  mul %kind 76 65536
  add %result %kind %new_pos
  ret %result
_with_colon:
  add %new_pos %new_pos 1
  mul %kind 76 65536
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# ============================================
# Numeric Literal Scanning
# ============================================

# scan_decimal_length: Count decimal digits starting at pos
@node scan_decimal_length
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= 0
  call %ch peek source pos
  lt %is_eof %ch 0
  jif %is_eof _zero
  xcall %is_d is_digit %ch
  eq %not_digit %is_d 0
  jif %not_digit _zero
  add %next_pos pos 1
  call %rest_len scan_decimal_length source %next_pos
  add %total %rest_len 1
  ret %total
_zero:
  mov %result 0
  ret %result

# parse_decimal_value: Parse decimal integer from source
# Returns the numeric value (i32 for now, i64 would need special handling)
@node parse_decimal_value
@params source:i32 start:i32 len:i32
@returns i32
@pre start >= 0
@pre len > 0
@post true
  mov %value 0
  mov %i 0
_loop:
  ge %done %i len
  jif %done _done
  add %src_pos start %i
  xcall %byte string_get_byte source %src_pos
  # Convert ASCII digit to value: byte - 48
  sub %digit %byte 48
  mul %value %value 10
  add %value %value %digit
  add %i %i 1
  jmp _loop
_done:
  ret %value

# scan_hex_length: Count hex digits after 0x prefix
@node scan_hex_length
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= 0
  call %ch peek source pos
  lt %is_eof %ch 0
  jif %is_eof _zero
  call %is_h is_hex_digit %ch
  eq %not_hex %is_h 0
  jif %not_hex _zero
  add %next_pos pos 1
  call %rest_len scan_hex_length source %next_pos
  add %total %rest_len 1
  ret %total
_zero:
  mov %result 0
  ret %result

# scan_number: Scan integer literal (decimal or hex)
# Returns packed (kind << 16) | new_pos, or -1
# IntLit = 71 (with value stored separately - for now just position)
@node scan_number
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  xcall %is_d is_digit %ch
  eq %not_digit %is_d 0
  jif %not_digit _not_matched

  # Check for hex prefix: 0x
  eq %is_zero %ch 48
  jif %is_zero _check_hex

_decimal:
  call %len scan_decimal_length source pos
  add %new_pos pos %len
  # IntLit = 71
  mul %kind 71 65536
  add %result %kind %new_pos
  ret %result

_check_hex:
  call %next peek_next source pos
  # Check for 'x' (120) or 'X' (88)
  eq %is_x %next 120
  jif %is_x _hex
  eq %is_X %next 88
  jif %is_X _hex
  # Just a regular decimal starting with 0
  jmp _decimal

_hex:
  add %hex_start pos 2
  call %hex_len scan_hex_length source %hex_start
  eq %no_hex %hex_len 0
  jif %no_hex _not_matched
  add %new_pos pos 2
  add %new_pos %new_pos %hex_len
  mul %kind 71 65536
  add %result %kind %new_pos
  ret %result

_not_matched:
  mov %result -1
  ret %result

# ============================================
# String Literal Scanning
# ============================================

# scan_string_literal: Scan "..." string literal
# Returns packed (kind << 16) | new_pos, or -1
# StringLit = 73
@node scan_string_literal
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  # Check for opening quote (34)
  ne %not_quote %ch 34
  jif %not_quote _not_matched

  add %content_start pos 1
  call %end_pos scan_string_content source %content_start
  lt %no_end %end_pos 0
  jif %no_end _not_matched

  # end_pos points to closing quote, advance past it
  add %new_pos %end_pos 1
  # StringLit = 73
  mul %kind 73 65536
  add %result %kind %new_pos
  ret %result

_not_matched:
  mov %result -1
  ret %result

# scan_string_content: Find closing quote, return its position
# Returns -1 if not found (unclosed string)
@node scan_string_content
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %at_end is_at_end source pos
  ne %is_end %at_end 0
  jif %is_end _unclosed

  call %ch peek source pos
  # Check for closing quote
  eq %is_close %ch 34
  jif %is_close _found

  # Check for newline (unclosed)
  eq %is_newline %ch 10
  jif %is_newline _unclosed

  # Check for escape (backslash = 92)
  eq %is_escape %ch 92
  jif %is_escape _escape

  # Regular char, continue
  add %next_pos pos 1
  call %result scan_string_content source %next_pos
  ret %result

_escape:
  # Skip escape char and next char
  add %skip_pos pos 2
  call %result scan_string_content source %skip_pos
  ret %result

_found:
  ret pos

_unclosed:
  mov %result -1
  ret %result

# scan_token: Main token scanning entry point
# Returns packed result: (kind << 16) | new_pos, or (EOF << 16) | pos at end
@node scan_token
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= 0
  # Skip leading whitespace (but not newlines - they are significant)
  call %check_end is_at_end source pos
  ne %at_end %check_end 0
  jif %at_end _eof

  # Check for newline (TokenKind::Newline = 77)
  call %ch peek source pos
  eq %is_newline %ch 10
  jif %is_newline _newline

  # Skip non-newline whitespace
  xcall %is_ws is_whitespace %ch
  ne %ws_bool %is_ws 0
  jif %ws_bool _skip_ws

  # Try string literal first (before other tokens)
  call %str_result scan_string_literal source pos
  ge %str_matched %str_result 0
  jif %str_matched _return_str

  # Try number literal
  call %num_result scan_number source pos
  ge %num_matched %num_result 0
  jif %num_matched _return_num

  # Try register (%name) - must check before % as single-char token
  call %reg_result scan_register source pos
  ge %reg_matched %reg_result 0
  jif %reg_matched _return_reg

  # Try label (_name)
  call %label_result scan_label source pos
  ge %label_matched %label_result 0
  jif %label_matched _return_label

  # Try multi-char tokens (::, =>, ==, !=, <=, >=)
  call %multi_result scan_multi_char source pos
  ge %multi_matched %multi_result 0
  jif %multi_matched _return_multi

  # Try single-char token
  call %single_result scan_single_char_token source pos
  ge %single_matched %single_result 0
  jif %single_matched _return_single

  # Try identifier
  call %ident_result scan_identifier_or_keyword source pos
  ge %ident_matched %ident_result 0
  jif %ident_matched _return_ident

  # Not a recognized token - return Error (80) and advance
  mul %err_kind 80 65536
  add %new_pos pos 1
  add %result %err_kind %new_pos
  ret %result

_skip_ws:
  add %ws_pos pos 1
  call %result scan_token source %ws_pos
  ret %result

_newline:
  mul %nl_kind 77 65536
  add %nl_pos pos 1
  add %result %nl_kind %nl_pos
  ret %result

_return_str:
  ret %str_result

_return_num:
  ret %num_result

_return_ident:
  ret %ident_result

_return_label:
  ret %label_result

_return_reg:
  ret %reg_result

_return_multi:
  ret %multi_result

_return_single:
  ret %single_result

_eof:
  # EOF token = 79
  mul %eof_kind 79 65536
  add %result %eof_kind pos
  ret %result
