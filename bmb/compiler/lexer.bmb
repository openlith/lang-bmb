# BMB Self-Hosting Compiler - Lexer
# v0.16.0: Lexer & Tokenizer in BMB
#
# Philosophy: "Omission is guessing, and guessing is error"
# Explicit state tracking, no hidden side effects.

@use "token"

# Host function declarations for string operations
@extern "C" from "bmb_stdlib"
@node string_len_h
@params handle:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node string_get_byte
@params handle:i32 index:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node string_new
@params
@returns i32

@extern "C" from "bmb_stdlib"
@node string_push_byte
@params handle:i32 byte:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node string_drop
@params handle:i32
@returns i32

# Host function declarations for character classification
@extern "C" from "bmb_stdlib"
@node is_digit
@params byte:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node is_alpha
@params byte:i32
@returns i32

@extern "C" from "bmb_stdlib"
@node is_whitespace
@params byte:i32
@returns i32

# Lexer state - passed explicitly to all functions
# (BMB doesn't have mutable structs yet, so we use separate parameters)

# ============================================
# Character Utilities
# ============================================

# is_at_end: Check if lexer has reached end of source
@node is_at_end
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  xcall %len string_len_h source
  ge %cmp pos %len
  jif %cmp _yes
  mov %result 0
  ret %result
_yes:
  mov %result 1
  ret %result

# peek: Look at current character without consuming
# Returns -1 if at end
@node peek
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= -1
  call %at_end is_at_end source pos
  ne %at_end_bool %at_end 0
  jif %at_end_bool _eof
  xcall %byte string_get_byte source pos
  ret %byte
_eof:
  mov %result -1
  ret %result

# peek_next: Look at next character (pos+1) without consuming
# Returns -1 if would be at or past end
@node peek_next
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= -1
  add %next_pos pos 1
  call %at_end is_at_end source %next_pos
  ne %at_end_bool %at_end 0
  jif %at_end_bool _eof
  xcall %byte string_get_byte source %next_pos
  ret %byte
_eof:
  mov %result -1
  ret %result

# advance: Consume current character and return new position
# Returns pos+1 if not at end, pos if at end
@node advance
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= pos
  call %at_end is_at_end source pos
  ne %at_end_bool %at_end 0
  jif %at_end_bool _stay
  add %new_pos pos 1
  ret %new_pos
_stay:
  ret pos

# skip_whitespace: Skip whitespace characters, return new position
@node skip_whitespace
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= pos
  call %at_end is_at_end source pos
  ne %at_end_bool %at_end 0
  jif %at_end_bool _done
  call %ch peek source pos
  xcall %is_ws is_whitespace %ch
  eq %not_ws %is_ws 0
  jif %not_ws _done
  # Whitespace found, advance and recurse
  call %new_pos advance source pos
  call %result skip_whitespace source %new_pos
  ret %result
_done:
  ret pos

# ============================================
# Character Classification (BMB-specific)
# ============================================

# is_ident_start: Check if character can start an identifier
# Identifiers start with alpha or underscore
@node is_ident_start
@params byte:i32
@returns i32
@pre true
@post true
  # Check alpha
  xcall %is_a is_alpha byte
  ne %is_alpha_bool %is_a 0
  jif %is_alpha_bool _yes
  # Check underscore (95)
  eq %is_underscore byte 95
  jif %is_underscore _yes
  mov %result 0
  ret %result
_yes:
  mov %result 1
  ret %result

# is_ident_continue: Check if character can continue an identifier
# Identifiers continue with alphanumeric or underscore
@node is_ident_continue
@params byte:i32
@returns i32
@pre true
@post true
  # Check alpha
  xcall %is_a is_alpha byte
  ne %is_alpha_bool %is_a 0
  jif %is_alpha_bool _yes
  # Check digit
  xcall %is_d is_digit byte
  ne %is_digit_bool %is_d 0
  jif %is_digit_bool _yes
  # Check underscore (95)
  eq %is_underscore byte 95
  jif %is_underscore _yes
  mov %result 0
  ret %result
_yes:
  mov %result 1
  ret %result

# is_hex_digit: Check if character is hexadecimal digit
@node is_hex_digit
@params byte:i32
@returns i32
@pre true
@post true
  # Check 0-9
  xcall %is_d is_digit byte
  ne %is_digit_bool %is_d 0
  jif %is_digit_bool _yes
  # Check a-f (97-102)
  ge %ge_a byte 97
  le %le_f byte 102
  and %is_lower_hex %ge_a %le_f
  jif %is_lower_hex _yes
  # Check A-F (65-70)
  ge %ge_A byte 65
  le %le_F byte 70
  and %is_upper_hex %ge_A %le_F
  jif %is_upper_hex _yes
  mov %result 0
  ret %result
_yes:
  mov %result 1
  ret %result

# ============================================
# Single Character Token Detection
# ============================================

# ASCII character codes for reference:
# '@' = 64, ':' = 58, '%' = 37, '(' = 40, ')' = 41
# '[' = 91, ']' = 93, '{' = 123, '}' = 125, ',' = 44
# '+' = 43, '-' = 45, '*' = 42, '/' = 47
# '=' = 61, '!' = 33, '<' = 60, '>' = 62
# '&' = 38, '|' = 124, '^' = 94, '_' = 95
# '#' = 35, '\n' = 10

# get_single_char_token: Map single character to TokenKind
# Returns -1 if not a single-char token
@node get_single_char_token
@params byte:i32
@returns i32
@pre byte >= 0
@post ret >= -1
  # '@' = 64 -> At (45)
  eq %is_at byte 64
  jif %is_at _at
  # ':' = 58 -> Colon (46)
  eq %is_colon byte 58
  jif %is_colon _colon
  # '%' = 37 -> Percent (47)
  eq %is_percent byte 37
  jif %is_percent _percent
  # '(' = 40 -> LParen (48)
  eq %is_lparen byte 40
  jif %is_lparen _lparen
  # ')' = 41 -> RParen (49)
  eq %is_rparen byte 41
  jif %is_rparen _rparen
  # '[' = 91 -> LBracket (50)
  eq %is_lbracket byte 91
  jif %is_lbracket _lbracket
  # ']' = 93 -> RBracket (51)
  eq %is_rbracket byte 93
  jif %is_rbracket _rbracket
  # '{' = 123 -> LBrace (52)
  eq %is_lbrace byte 123
  jif %is_lbrace _lbrace
  # '}' = 125 -> RBrace (53)
  eq %is_rbrace byte 125
  jif %is_rbrace _rbrace
  # ',' = 44 -> Comma (54)
  eq %is_comma byte 44
  jif %is_comma _comma
  # '+' = 43 -> Plus (58)
  eq %is_plus byte 43
  jif %is_plus _plus
  # '*' = 42 -> Star (60)
  eq %is_star byte 42
  jif %is_star _star
  # '/' = 47 -> Slash (61)
  eq %is_slash byte 47
  jif %is_slash _slash
  # '&' = 38 -> Ampersand (62)
  eq %is_amp byte 38
  jif %is_amp _amp
  # '|' = 124 -> Pipe (63)
  eq %is_pipe byte 124
  jif %is_pipe _pipe
  # '^' = 94 -> Caret (64)
  eq %is_caret byte 94
  jif %is_caret _caret
  # '\n' = 10 -> Newline (78)
  eq %is_newline byte 10
  jif %is_newline _newline
  # Not a single-char token
  mov %result -1
  ret %result

  # Labels in reverse order (workaround for label ordering bug)
_newline:
  mov %result 78
  ret %result
_caret:
  mov %result 64
  ret %result
_pipe:
  mov %result 63
  ret %result
_amp:
  mov %result 62
  ret %result
_slash:
  mov %result 61
  ret %result
_star:
  mov %result 60
  ret %result
_plus:
  mov %result 58
  ret %result
_comma:
  mov %result 54
  ret %result
_rbrace:
  mov %result 53
  ret %result
_lbrace:
  mov %result 52
  ret %result
_rbracket:
  mov %result 51
  ret %result
_lbracket:
  mov %result 50
  ret %result
_rparen:
  mov %result 49
  ret %result
_lparen:
  mov %result 48
  ret %result
_percent:
  mov %result 47
  ret %result
_colon:
  mov %result 46
  ret %result
_at:
  mov %result 45
  ret %result

# ============================================
# Lexer State
# State is passed as separate parameters until BMB supports mutable structs.
# Parameters: source (handle), pos, line, col, token_start
# ============================================

# ============================================
# Token Scanning
# ============================================

# scan_single_char_token: Try to scan a single-character token
# Returns: (token_kind << 16) | new_pos if matched, -1 if not matched
# Using packed return: high 16 bits = token kind, low 16 bits = new position
@node scan_single_char_token
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  lt %is_eof %ch 0
  jif %is_eof _not_matched
  call %kind get_single_char_token %ch
  lt %not_single %kind 0
  jif %not_single _not_matched
  # Matched! Pack (kind << 16) | (pos + 1)
  mul %kind_shifted %kind 65536
  add %new_pos pos 1
  add %result %kind_shifted %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# unpack_token_kind: Extract token kind from packed result
@node unpack_token_kind
@params packed:i32
@returns i32
@pre packed >= 0
@post ret >= 0
  div %kind packed 65536
  ret %kind

# unpack_position: Extract position from packed result
@node unpack_position
@params packed:i32
@returns i32
@pre packed >= 0
@post ret >= 0
  mod %pos packed 65536
  ret %pos

# ============================================
# Multi-Character Token Scanning
# ============================================

# ASCII codes: '=' = 61, '!' = 33, '<' = 60, '>' = 62, ':' = 58, '-' = 45

# scan_equals: Handle = and =>  and ==
# Returns packed result or -1 if not '='
@node scan_equals
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_eq %ch 61
  jif %not_eq _not_matched
  call %next peek_next source pos
  # Check for => (Arrow = 55)
  eq %is_arrow %next 62
  jif %is_arrow _arrow
  # Check for == (EqEq = 65)
  eq %is_eqeq %next 61
  jif %is_eqeq _eqeq
  # Single = is not a token in BMB (use mov opcode)
  mov %result -1
  ret %result
_arrow:
  mul %kind 55 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_eqeq:
  mul %kind 65 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_bang: Handle ! and !=
@node scan_bang
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_bang %ch 33
  jif %not_bang _not_matched
  call %next peek_next source pos
  # Check for != (BangEq = 66)
  eq %is_bangeq %next 61
  jif %is_bangeq _bangeq
  # Single ! is not used in BMB
  mov %result -1
  ret %result
_bangeq:
  mul %kind 66 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_less: Handle < and <=
@node scan_less
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_less %ch 60
  jif %not_less _not_matched
  call %next peek_next source pos
  # Check for <= (LeOp = 68)
  eq %is_leop %next 61
  jif %is_leop _leop
  # Single < (LtOp = 67)
  mul %kind 67 65536
  add %new_pos pos 1
  add %result %kind %new_pos
  ret %result
_leop:
  mul %kind 68 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_greater: Handle > and >=
@node scan_greater
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_greater %ch 62
  jif %not_greater _not_matched
  call %next peek_next source pos
  # Check for >= (GeOp = 70)
  eq %is_geop %next 61
  jif %is_geop _geop
  # Single > (GtOp = 69)
  mul %kind 69 65536
  add %new_pos pos 1
  add %result %kind %new_pos
  ret %result
_geop:
  mul %kind 70 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_colon_double: Handle :: (ColonColon = 56)
# Single : is handled by get_single_char_token
@node scan_colon_double
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_colon %ch 58
  jif %not_colon _not_matched
  call %next peek_next source pos
  eq %is_double %next 58
  jif %is_double _double
  mov %result -1
  ret %result
_double:
  mul %kind 56 65536
  add %new_pos pos 2
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_minus: Handle - (Minus = 59)
# Note: -> is not used in BMB, we use => for arrows
@node scan_minus
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  call %ch peek source pos
  ne %not_minus %ch 45
  jif %not_minus _not_matched
  # Simple minus token (Minus = 59)
  mul %kind 59 65536
  add %new_pos pos 1
  add %result %kind %new_pos
  ret %result
_not_matched:
  mov %result -1
  ret %result

# scan_multi_char: Try all multi-character token patterns
@node scan_multi_char
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post true
  # Try :: first (before single :)
  call %colon_result scan_colon_double source pos
  ge %colon_matched %colon_result 0
  jif %colon_matched _return_colon
  # Try =>  and ==
  call %eq_result scan_equals source pos
  ge %eq_matched %eq_result 0
  jif %eq_matched _return_eq
  # Try !=
  call %bang_result scan_bang source pos
  ge %bang_matched %bang_result 0
  jif %bang_matched _return_bang
  # Try < and <=
  call %less_result scan_less source pos
  ge %less_matched %less_result 0
  jif %less_matched _return_less
  # Try > and >=
  call %greater_result scan_greater source pos
  ge %greater_matched %greater_result 0
  jif %greater_matched _return_greater
  # Try -
  call %minus_result scan_minus source pos
  ge %minus_matched %minus_result 0
  jif %minus_matched _return_minus
  # No match
  mov %result -1
  ret %result
_return_minus:
  ret %minus_result
_return_greater:
  ret %greater_result
_return_less:
  ret %less_result
_return_bang:
  ret %bang_result
_return_eq:
  ret %eq_result
_return_colon:
  ret %colon_result

# scan_token: Main token scanning entry point
# Returns packed result: (kind << 16) | new_pos, or (EOF << 16) | pos at end
@node scan_token
@params source:i32 pos:i32
@returns i32
@pre pos >= 0
@post ret >= 0
  # Skip leading whitespace (but not newlines - they are significant)
  call %check_end is_at_end source pos
  ne %at_end %check_end 0
  jif %at_end _eof

  # Check for newline (TokenKind::Newline = 77)
  call %ch peek source pos
  eq %is_newline %ch 10
  jif %is_newline _newline

  # Skip non-newline whitespace
  xcall %is_ws is_whitespace %ch
  ne %ws_bool %is_ws 0
  jif %ws_bool _skip_ws

  # Try multi-char tokens first (::, =>, ==, !=, <=, >=)
  call %multi_result scan_multi_char source pos
  ge %multi_matched %multi_result 0
  jif %multi_matched _return_multi

  # Try single-char token
  call %single_result scan_single_char_token source pos
  ge %single_matched %single_result 0
  jif %single_matched _return_single

  # Not a recognized token - will be handled by other phases
  # For now, return Error token (80) and advance
  mul %err_kind 80 65536
  add %new_pos pos 1
  add %result %err_kind %new_pos
  ret %result

_skip_ws:
  add %ws_pos pos 1
  call %result scan_token source %ws_pos
  ret %result

_newline:
  mul %nl_kind 77 65536
  add %nl_pos pos 1
  add %result %nl_kind %nl_pos
  ret %result

_return_multi:
  ret %multi_result

_return_single:
  ret %single_result

_eof:
  # EOF token = 79
  mul %eof_kind 79 65536
  add %result %eof_kind pos
  ret %result
